// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/mrzack99s/mrz-identity-management/ent/groupbandwidth"
	"github.com/mrzack99s/mrz-identity-management/ent/groups"
	"github.com/mrzack99s/mrz-identity-management/ent/onlinesession"
	"github.com/mrzack99s/mrz-identity-management/ent/predicate"
	"github.com/mrzack99s/mrz-identity-management/ent/users"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGroupBandwidth = "GroupBandwidth"
	TypeGroups         = "Groups"
	TypeOnlineSession  = "OnlineSession"
	TypeUsers          = "Users"
)

// GroupBandwidthMutation represents an operation that mutates the GroupBandwidth nodes in the graph.
type GroupBandwidthMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	gbw_download_speed    *int
	addgbw_download_speed *int
	gbw_upload_speed      *int
	addgbw_upload_speed   *int
	gbw_created_at        *time.Time
	clearedFields         map[string]struct{}
	groups                map[int]struct{}
	removedgroups         map[int]struct{}
	clearedgroups         bool
	done                  bool
	oldValue              func(context.Context) (*GroupBandwidth, error)
	predicates            []predicate.GroupBandwidth
}

var _ ent.Mutation = (*GroupBandwidthMutation)(nil)

// groupbandwidthOption allows management of the mutation configuration using functional options.
type groupbandwidthOption func(*GroupBandwidthMutation)

// newGroupBandwidthMutation creates new mutation for the GroupBandwidth entity.
func newGroupBandwidthMutation(c config, op Op, opts ...groupbandwidthOption) *GroupBandwidthMutation {
	m := &GroupBandwidthMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupBandwidth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupBandwidthID sets the ID field of the mutation.
func withGroupBandwidthID(id int) groupbandwidthOption {
	return func(m *GroupBandwidthMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupBandwidth
		)
		m.oldValue = func(ctx context.Context) (*GroupBandwidth, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupBandwidth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupBandwidth sets the old GroupBandwidth of the mutation.
func withGroupBandwidth(node *GroupBandwidth) groupbandwidthOption {
	return func(m *GroupBandwidthMutation) {
		m.oldValue = func(context.Context) (*GroupBandwidth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupBandwidthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupBandwidthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupBandwidthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGbwDownloadSpeed sets the "gbw_download_speed" field.
func (m *GroupBandwidthMutation) SetGbwDownloadSpeed(i int) {
	m.gbw_download_speed = &i
	m.addgbw_download_speed = nil
}

// GbwDownloadSpeed returns the value of the "gbw_download_speed" field in the mutation.
func (m *GroupBandwidthMutation) GbwDownloadSpeed() (r int, exists bool) {
	v := m.gbw_download_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldGbwDownloadSpeed returns the old "gbw_download_speed" field's value of the GroupBandwidth entity.
// If the GroupBandwidth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupBandwidthMutation) OldGbwDownloadSpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGbwDownloadSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGbwDownloadSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGbwDownloadSpeed: %w", err)
	}
	return oldValue.GbwDownloadSpeed, nil
}

// AddGbwDownloadSpeed adds i to the "gbw_download_speed" field.
func (m *GroupBandwidthMutation) AddGbwDownloadSpeed(i int) {
	if m.addgbw_download_speed != nil {
		*m.addgbw_download_speed += i
	} else {
		m.addgbw_download_speed = &i
	}
}

// AddedGbwDownloadSpeed returns the value that was added to the "gbw_download_speed" field in this mutation.
func (m *GroupBandwidthMutation) AddedGbwDownloadSpeed() (r int, exists bool) {
	v := m.addgbw_download_speed
	if v == nil {
		return
	}
	return *v, true
}

// ResetGbwDownloadSpeed resets all changes to the "gbw_download_speed" field.
func (m *GroupBandwidthMutation) ResetGbwDownloadSpeed() {
	m.gbw_download_speed = nil
	m.addgbw_download_speed = nil
}

// SetGbwUploadSpeed sets the "gbw_upload_speed" field.
func (m *GroupBandwidthMutation) SetGbwUploadSpeed(i int) {
	m.gbw_upload_speed = &i
	m.addgbw_upload_speed = nil
}

// GbwUploadSpeed returns the value of the "gbw_upload_speed" field in the mutation.
func (m *GroupBandwidthMutation) GbwUploadSpeed() (r int, exists bool) {
	v := m.gbw_upload_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldGbwUploadSpeed returns the old "gbw_upload_speed" field's value of the GroupBandwidth entity.
// If the GroupBandwidth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupBandwidthMutation) OldGbwUploadSpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGbwUploadSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGbwUploadSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGbwUploadSpeed: %w", err)
	}
	return oldValue.GbwUploadSpeed, nil
}

// AddGbwUploadSpeed adds i to the "gbw_upload_speed" field.
func (m *GroupBandwidthMutation) AddGbwUploadSpeed(i int) {
	if m.addgbw_upload_speed != nil {
		*m.addgbw_upload_speed += i
	} else {
		m.addgbw_upload_speed = &i
	}
}

// AddedGbwUploadSpeed returns the value that was added to the "gbw_upload_speed" field in this mutation.
func (m *GroupBandwidthMutation) AddedGbwUploadSpeed() (r int, exists bool) {
	v := m.addgbw_upload_speed
	if v == nil {
		return
	}
	return *v, true
}

// ResetGbwUploadSpeed resets all changes to the "gbw_upload_speed" field.
func (m *GroupBandwidthMutation) ResetGbwUploadSpeed() {
	m.gbw_upload_speed = nil
	m.addgbw_upload_speed = nil
}

// SetGbwCreatedAt sets the "gbw_created_at" field.
func (m *GroupBandwidthMutation) SetGbwCreatedAt(t time.Time) {
	m.gbw_created_at = &t
}

// GbwCreatedAt returns the value of the "gbw_created_at" field in the mutation.
func (m *GroupBandwidthMutation) GbwCreatedAt() (r time.Time, exists bool) {
	v := m.gbw_created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGbwCreatedAt returns the old "gbw_created_at" field's value of the GroupBandwidth entity.
// If the GroupBandwidth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupBandwidthMutation) OldGbwCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGbwCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGbwCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGbwCreatedAt: %w", err)
	}
	return oldValue.GbwCreatedAt, nil
}

// ClearGbwCreatedAt clears the value of the "gbw_created_at" field.
func (m *GroupBandwidthMutation) ClearGbwCreatedAt() {
	m.gbw_created_at = nil
	m.clearedFields[groupbandwidth.FieldGbwCreatedAt] = struct{}{}
}

// GbwCreatedAtCleared returns if the "gbw_created_at" field was cleared in this mutation.
func (m *GroupBandwidthMutation) GbwCreatedAtCleared() bool {
	_, ok := m.clearedFields[groupbandwidth.FieldGbwCreatedAt]
	return ok
}

// ResetGbwCreatedAt resets all changes to the "gbw_created_at" field.
func (m *GroupBandwidthMutation) ResetGbwCreatedAt() {
	m.gbw_created_at = nil
	delete(m.clearedFields, groupbandwidth.FieldGbwCreatedAt)
}

// AddGroupIDs adds the "groups" edge to the Groups entity by ids.
func (m *GroupBandwidthMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Groups entity.
func (m *GroupBandwidthMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Groups entity was cleared.
func (m *GroupBandwidthMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Groups entity by IDs.
func (m *GroupBandwidthMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Groups entity.
func (m *GroupBandwidthMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *GroupBandwidthMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *GroupBandwidthMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// Where appends a list predicates to the GroupBandwidthMutation builder.
func (m *GroupBandwidthMutation) Where(ps ...predicate.GroupBandwidth) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GroupBandwidthMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GroupBandwidth).
func (m *GroupBandwidthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupBandwidthMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.gbw_download_speed != nil {
		fields = append(fields, groupbandwidth.FieldGbwDownloadSpeed)
	}
	if m.gbw_upload_speed != nil {
		fields = append(fields, groupbandwidth.FieldGbwUploadSpeed)
	}
	if m.gbw_created_at != nil {
		fields = append(fields, groupbandwidth.FieldGbwCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupBandwidthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupbandwidth.FieldGbwDownloadSpeed:
		return m.GbwDownloadSpeed()
	case groupbandwidth.FieldGbwUploadSpeed:
		return m.GbwUploadSpeed()
	case groupbandwidth.FieldGbwCreatedAt:
		return m.GbwCreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupBandwidthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupbandwidth.FieldGbwDownloadSpeed:
		return m.OldGbwDownloadSpeed(ctx)
	case groupbandwidth.FieldGbwUploadSpeed:
		return m.OldGbwUploadSpeed(ctx)
	case groupbandwidth.FieldGbwCreatedAt:
		return m.OldGbwCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GroupBandwidth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupBandwidthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupbandwidth.FieldGbwDownloadSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGbwDownloadSpeed(v)
		return nil
	case groupbandwidth.FieldGbwUploadSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGbwUploadSpeed(v)
		return nil
	case groupbandwidth.FieldGbwCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGbwCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GroupBandwidth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupBandwidthMutation) AddedFields() []string {
	var fields []string
	if m.addgbw_download_speed != nil {
		fields = append(fields, groupbandwidth.FieldGbwDownloadSpeed)
	}
	if m.addgbw_upload_speed != nil {
		fields = append(fields, groupbandwidth.FieldGbwUploadSpeed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupBandwidthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case groupbandwidth.FieldGbwDownloadSpeed:
		return m.AddedGbwDownloadSpeed()
	case groupbandwidth.FieldGbwUploadSpeed:
		return m.AddedGbwUploadSpeed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupBandwidthMutation) AddField(name string, value ent.Value) error {
	switch name {
	case groupbandwidth.FieldGbwDownloadSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGbwDownloadSpeed(v)
		return nil
	case groupbandwidth.FieldGbwUploadSpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGbwUploadSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown GroupBandwidth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupBandwidthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupbandwidth.FieldGbwCreatedAt) {
		fields = append(fields, groupbandwidth.FieldGbwCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupBandwidthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupBandwidthMutation) ClearField(name string) error {
	switch name {
	case groupbandwidth.FieldGbwCreatedAt:
		m.ClearGbwCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GroupBandwidth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupBandwidthMutation) ResetField(name string) error {
	switch name {
	case groupbandwidth.FieldGbwDownloadSpeed:
		m.ResetGbwDownloadSpeed()
		return nil
	case groupbandwidth.FieldGbwUploadSpeed:
		m.ResetGbwUploadSpeed()
		return nil
	case groupbandwidth.FieldGbwCreatedAt:
		m.ResetGbwCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GroupBandwidth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupBandwidthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.groups != nil {
		edges = append(edges, groupbandwidth.EdgeGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupBandwidthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groupbandwidth.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupBandwidthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgroups != nil {
		edges = append(edges, groupbandwidth.EdgeGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupBandwidthMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case groupbandwidth.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupBandwidthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroups {
		edges = append(edges, groupbandwidth.EdgeGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupBandwidthMutation) EdgeCleared(name string) bool {
	switch name {
	case groupbandwidth.EdgeGroups:
		return m.clearedgroups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupBandwidthMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupBandwidth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupBandwidthMutation) ResetEdge(name string) error {
	switch name {
	case groupbandwidth.EdgeGroups:
		m.ResetGroups()
		return nil
	}
	return fmt.Errorf("unknown GroupBandwidth edge %s", name)
}

// GroupsMutation represents an operation that mutates the Groups nodes in the graph.
type GroupsMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	g_name               *string
	g_is_int_org         *bool
	g_is_super_admin     *bool
	g_created_at         *time.Time
	clearedFields        map[string]struct{}
	use_bandwidth        *int
	cleareduse_bandwidth bool
	users                map[int]struct{}
	removedusers         map[int]struct{}
	clearedusers         bool
	done                 bool
	oldValue             func(context.Context) (*Groups, error)
	predicates           []predicate.Groups
}

var _ ent.Mutation = (*GroupsMutation)(nil)

// groupsOption allows management of the mutation configuration using functional options.
type groupsOption func(*GroupsMutation)

// newGroupsMutation creates new mutation for the Groups entity.
func newGroupsMutation(c config, op Op, opts ...groupsOption) *GroupsMutation {
	m := &GroupsMutation{
		config:        c,
		op:            op,
		typ:           TypeGroups,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupsID sets the ID field of the mutation.
func withGroupsID(id int) groupsOption {
	return func(m *GroupsMutation) {
		var (
			err   error
			once  sync.Once
			value *Groups
		)
		m.oldValue = func(ctx context.Context) (*Groups, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Groups.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroups sets the old Groups of the mutation.
func withGroups(node *Groups) groupsOption {
	return func(m *GroupsMutation) {
		m.oldValue = func(context.Context) (*Groups, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGName sets the "g_name" field.
func (m *GroupsMutation) SetGName(s string) {
	m.g_name = &s
}

// GName returns the value of the "g_name" field in the mutation.
func (m *GroupsMutation) GName() (r string, exists bool) {
	v := m.g_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGName returns the old "g_name" field's value of the Groups entity.
// If the Groups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupsMutation) OldGName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGName: %w", err)
	}
	return oldValue.GName, nil
}

// ResetGName resets all changes to the "g_name" field.
func (m *GroupsMutation) ResetGName() {
	m.g_name = nil
}

// SetGIsIntOrg sets the "g_is_int_org" field.
func (m *GroupsMutation) SetGIsIntOrg(b bool) {
	m.g_is_int_org = &b
}

// GIsIntOrg returns the value of the "g_is_int_org" field in the mutation.
func (m *GroupsMutation) GIsIntOrg() (r bool, exists bool) {
	v := m.g_is_int_org
	if v == nil {
		return
	}
	return *v, true
}

// OldGIsIntOrg returns the old "g_is_int_org" field's value of the Groups entity.
// If the Groups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupsMutation) OldGIsIntOrg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGIsIntOrg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGIsIntOrg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGIsIntOrg: %w", err)
	}
	return oldValue.GIsIntOrg, nil
}

// ResetGIsIntOrg resets all changes to the "g_is_int_org" field.
func (m *GroupsMutation) ResetGIsIntOrg() {
	m.g_is_int_org = nil
}

// SetGIsSuperAdmin sets the "g_is_super_admin" field.
func (m *GroupsMutation) SetGIsSuperAdmin(b bool) {
	m.g_is_super_admin = &b
}

// GIsSuperAdmin returns the value of the "g_is_super_admin" field in the mutation.
func (m *GroupsMutation) GIsSuperAdmin() (r bool, exists bool) {
	v := m.g_is_super_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldGIsSuperAdmin returns the old "g_is_super_admin" field's value of the Groups entity.
// If the Groups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupsMutation) OldGIsSuperAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGIsSuperAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGIsSuperAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGIsSuperAdmin: %w", err)
	}
	return oldValue.GIsSuperAdmin, nil
}

// ResetGIsSuperAdmin resets all changes to the "g_is_super_admin" field.
func (m *GroupsMutation) ResetGIsSuperAdmin() {
	m.g_is_super_admin = nil
}

// SetGCreatedAt sets the "g_created_at" field.
func (m *GroupsMutation) SetGCreatedAt(t time.Time) {
	m.g_created_at = &t
}

// GCreatedAt returns the value of the "g_created_at" field in the mutation.
func (m *GroupsMutation) GCreatedAt() (r time.Time, exists bool) {
	v := m.g_created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGCreatedAt returns the old "g_created_at" field's value of the Groups entity.
// If the Groups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupsMutation) OldGCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGCreatedAt: %w", err)
	}
	return oldValue.GCreatedAt, nil
}

// ClearGCreatedAt clears the value of the "g_created_at" field.
func (m *GroupsMutation) ClearGCreatedAt() {
	m.g_created_at = nil
	m.clearedFields[groups.FieldGCreatedAt] = struct{}{}
}

// GCreatedAtCleared returns if the "g_created_at" field was cleared in this mutation.
func (m *GroupsMutation) GCreatedAtCleared() bool {
	_, ok := m.clearedFields[groups.FieldGCreatedAt]
	return ok
}

// ResetGCreatedAt resets all changes to the "g_created_at" field.
func (m *GroupsMutation) ResetGCreatedAt() {
	m.g_created_at = nil
	delete(m.clearedFields, groups.FieldGCreatedAt)
}

// SetUseBandwidthID sets the "use_bandwidth" edge to the GroupBandwidth entity by id.
func (m *GroupsMutation) SetUseBandwidthID(id int) {
	m.use_bandwidth = &id
}

// ClearUseBandwidth clears the "use_bandwidth" edge to the GroupBandwidth entity.
func (m *GroupsMutation) ClearUseBandwidth() {
	m.cleareduse_bandwidth = true
}

// UseBandwidthCleared reports if the "use_bandwidth" edge to the GroupBandwidth entity was cleared.
func (m *GroupsMutation) UseBandwidthCleared() bool {
	return m.cleareduse_bandwidth
}

// UseBandwidthID returns the "use_bandwidth" edge ID in the mutation.
func (m *GroupsMutation) UseBandwidthID() (id int, exists bool) {
	if m.use_bandwidth != nil {
		return *m.use_bandwidth, true
	}
	return
}

// UseBandwidthIDs returns the "use_bandwidth" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UseBandwidthID instead. It exists only for internal usage by the builders.
func (m *GroupsMutation) UseBandwidthIDs() (ids []int) {
	if id := m.use_bandwidth; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUseBandwidth resets all changes to the "use_bandwidth" edge.
func (m *GroupsMutation) ResetUseBandwidth() {
	m.use_bandwidth = nil
	m.cleareduse_bandwidth = false
}

// AddUserIDs adds the "users" edge to the Users entity by ids.
func (m *GroupsMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *GroupsMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *GroupsMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the Users entity by IDs.
func (m *GroupsMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the Users entity.
func (m *GroupsMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupsMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the GroupsMutation builder.
func (m *GroupsMutation) Where(ps ...predicate.Groups) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GroupsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Groups).
func (m *GroupsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.g_name != nil {
		fields = append(fields, groups.FieldGName)
	}
	if m.g_is_int_org != nil {
		fields = append(fields, groups.FieldGIsIntOrg)
	}
	if m.g_is_super_admin != nil {
		fields = append(fields, groups.FieldGIsSuperAdmin)
	}
	if m.g_created_at != nil {
		fields = append(fields, groups.FieldGCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groups.FieldGName:
		return m.GName()
	case groups.FieldGIsIntOrg:
		return m.GIsIntOrg()
	case groups.FieldGIsSuperAdmin:
		return m.GIsSuperAdmin()
	case groups.FieldGCreatedAt:
		return m.GCreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groups.FieldGName:
		return m.OldGName(ctx)
	case groups.FieldGIsIntOrg:
		return m.OldGIsIntOrg(ctx)
	case groups.FieldGIsSuperAdmin:
		return m.OldGIsSuperAdmin(ctx)
	case groups.FieldGCreatedAt:
		return m.OldGCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Groups field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groups.FieldGName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGName(v)
		return nil
	case groups.FieldGIsIntOrg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGIsIntOrg(v)
		return nil
	case groups.FieldGIsSuperAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGIsSuperAdmin(v)
		return nil
	case groups.FieldGCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Groups field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Groups numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groups.FieldGCreatedAt) {
		fields = append(fields, groups.FieldGCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupsMutation) ClearField(name string) error {
	switch name {
	case groups.FieldGCreatedAt:
		m.ClearGCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Groups nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupsMutation) ResetField(name string) error {
	switch name {
	case groups.FieldGName:
		m.ResetGName()
		return nil
	case groups.FieldGIsIntOrg:
		m.ResetGIsIntOrg()
		return nil
	case groups.FieldGIsSuperAdmin:
		m.ResetGIsSuperAdmin()
		return nil
	case groups.FieldGCreatedAt:
		m.ResetGCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Groups field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.use_bandwidth != nil {
		edges = append(edges, groups.EdgeUseBandwidth)
	}
	if m.users != nil {
		edges = append(edges, groups.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groups.EdgeUseBandwidth:
		if id := m.use_bandwidth; id != nil {
			return []ent.Value{*id}
		}
	case groups.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, groups.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case groups.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduse_bandwidth {
		edges = append(edges, groups.EdgeUseBandwidth)
	}
	if m.clearedusers {
		edges = append(edges, groups.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupsMutation) EdgeCleared(name string) bool {
	switch name {
	case groups.EdgeUseBandwidth:
		return m.cleareduse_bandwidth
	case groups.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupsMutation) ClearEdge(name string) error {
	switch name {
	case groups.EdgeUseBandwidth:
		m.ClearUseBandwidth()
		return nil
	}
	return fmt.Errorf("unknown Groups unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupsMutation) ResetEdge(name string) error {
	switch name {
	case groups.EdgeUseBandwidth:
		m.ResetUseBandwidth()
		return nil
	case groups.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Groups edge %s", name)
}

// OnlineSessionMutation represents an operation that mutates the OnlineSession nodes in the graph.
type OnlineSessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	ip_address    *string
	u_pid         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OnlineSession, error)
	predicates    []predicate.OnlineSession
}

var _ ent.Mutation = (*OnlineSessionMutation)(nil)

// onlinesessionOption allows management of the mutation configuration using functional options.
type onlinesessionOption func(*OnlineSessionMutation)

// newOnlineSessionMutation creates new mutation for the OnlineSession entity.
func newOnlineSessionMutation(c config, op Op, opts ...onlinesessionOption) *OnlineSessionMutation {
	m := &OnlineSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeOnlineSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOnlineSessionID sets the ID field of the mutation.
func withOnlineSessionID(id int) onlinesessionOption {
	return func(m *OnlineSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *OnlineSession
		)
		m.oldValue = func(ctx context.Context) (*OnlineSession, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OnlineSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOnlineSession sets the old OnlineSession of the mutation.
func withOnlineSession(node *OnlineSession) onlinesessionOption {
	return func(m *OnlineSessionMutation) {
		m.oldValue = func(context.Context) (*OnlineSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OnlineSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OnlineSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OnlineSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetIPAddress sets the "ip_address" field.
func (m *OnlineSessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *OnlineSessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the OnlineSession entity.
// If the OnlineSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OnlineSessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *OnlineSessionMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetUPid sets the "u_pid" field.
func (m *OnlineSessionMutation) SetUPid(s string) {
	m.u_pid = &s
}

// UPid returns the value of the "u_pid" field in the mutation.
func (m *OnlineSessionMutation) UPid() (r string, exists bool) {
	v := m.u_pid
	if v == nil {
		return
	}
	return *v, true
}

// OldUPid returns the old "u_pid" field's value of the OnlineSession entity.
// If the OnlineSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OnlineSessionMutation) OldUPid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUPid: %w", err)
	}
	return oldValue.UPid, nil
}

// ResetUPid resets all changes to the "u_pid" field.
func (m *OnlineSessionMutation) ResetUPid() {
	m.u_pid = nil
}

// Where appends a list predicates to the OnlineSessionMutation builder.
func (m *OnlineSessionMutation) Where(ps ...predicate.OnlineSession) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OnlineSessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OnlineSession).
func (m *OnlineSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OnlineSessionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.ip_address != nil {
		fields = append(fields, onlinesession.FieldIPAddress)
	}
	if m.u_pid != nil {
		fields = append(fields, onlinesession.FieldUPid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OnlineSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case onlinesession.FieldIPAddress:
		return m.IPAddress()
	case onlinesession.FieldUPid:
		return m.UPid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OnlineSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case onlinesession.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case onlinesession.FieldUPid:
		return m.OldUPid(ctx)
	}
	return nil, fmt.Errorf("unknown OnlineSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OnlineSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case onlinesession.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case onlinesession.FieldUPid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUPid(v)
		return nil
	}
	return fmt.Errorf("unknown OnlineSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OnlineSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OnlineSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OnlineSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OnlineSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OnlineSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OnlineSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OnlineSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OnlineSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OnlineSessionMutation) ResetField(name string) error {
	switch name {
	case onlinesession.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case onlinesession.FieldUPid:
		m.ResetUPid()
		return nil
	}
	return fmt.Errorf("unknown OnlineSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OnlineSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OnlineSessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OnlineSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OnlineSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OnlineSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OnlineSessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OnlineSessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OnlineSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OnlineSessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OnlineSession edge %s", name)
}

// UsersMutation represents an operation that mutates the Users nodes in the graph.
type UsersMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	u_pid                 *string
	u_orgid               *string
	u_first_name          *string
	u_last_name           *string
	u_is_active           *bool
	u_created_at          *time.Time
	u_password_updated_at *time.Time
	u_expired_at          *time.Time
	clearedFields         map[string]struct{}
	in_group              *int
	clearedin_group       bool
	done                  bool
	oldValue              func(context.Context) (*Users, error)
	predicates            []predicate.Users
}

var _ ent.Mutation = (*UsersMutation)(nil)

// usersOption allows management of the mutation configuration using functional options.
type usersOption func(*UsersMutation)

// newUsersMutation creates new mutation for the Users entity.
func newUsersMutation(c config, op Op, opts ...usersOption) *UsersMutation {
	m := &UsersMutation{
		config:        c,
		op:            op,
		typ:           TypeUsers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsersID sets the ID field of the mutation.
func withUsersID(id int) usersOption {
	return func(m *UsersMutation) {
		var (
			err   error
			once  sync.Once
			value *Users
		)
		m.oldValue = func(ctx context.Context) (*Users, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Users.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsers sets the old Users of the mutation.
func withUsers(node *Users) usersOption {
	return func(m *UsersMutation) {
		m.oldValue = func(context.Context) (*Users, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUPid sets the "u_pid" field.
func (m *UsersMutation) SetUPid(s string) {
	m.u_pid = &s
}

// UPid returns the value of the "u_pid" field in the mutation.
func (m *UsersMutation) UPid() (r string, exists bool) {
	v := m.u_pid
	if v == nil {
		return
	}
	return *v, true
}

// OldUPid returns the old "u_pid" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUPid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUPid: %w", err)
	}
	return oldValue.UPid, nil
}

// ResetUPid resets all changes to the "u_pid" field.
func (m *UsersMutation) ResetUPid() {
	m.u_pid = nil
}

// SetUOrgid sets the "u_orgid" field.
func (m *UsersMutation) SetUOrgid(s string) {
	m.u_orgid = &s
}

// UOrgid returns the value of the "u_orgid" field in the mutation.
func (m *UsersMutation) UOrgid() (r string, exists bool) {
	v := m.u_orgid
	if v == nil {
		return
	}
	return *v, true
}

// OldUOrgid returns the old "u_orgid" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUOrgid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUOrgid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUOrgid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUOrgid: %w", err)
	}
	return oldValue.UOrgid, nil
}

// ResetUOrgid resets all changes to the "u_orgid" field.
func (m *UsersMutation) ResetUOrgid() {
	m.u_orgid = nil
}

// SetUFirstName sets the "u_first_name" field.
func (m *UsersMutation) SetUFirstName(s string) {
	m.u_first_name = &s
}

// UFirstName returns the value of the "u_first_name" field in the mutation.
func (m *UsersMutation) UFirstName() (r string, exists bool) {
	v := m.u_first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUFirstName returns the old "u_first_name" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUFirstName: %w", err)
	}
	return oldValue.UFirstName, nil
}

// ResetUFirstName resets all changes to the "u_first_name" field.
func (m *UsersMutation) ResetUFirstName() {
	m.u_first_name = nil
}

// SetULastName sets the "u_last_name" field.
func (m *UsersMutation) SetULastName(s string) {
	m.u_last_name = &s
}

// ULastName returns the value of the "u_last_name" field in the mutation.
func (m *UsersMutation) ULastName() (r string, exists bool) {
	v := m.u_last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldULastName returns the old "u_last_name" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldULastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldULastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldULastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldULastName: %w", err)
	}
	return oldValue.ULastName, nil
}

// ResetULastName resets all changes to the "u_last_name" field.
func (m *UsersMutation) ResetULastName() {
	m.u_last_name = nil
}

// SetUIsActive sets the "u_is_active" field.
func (m *UsersMutation) SetUIsActive(b bool) {
	m.u_is_active = &b
}

// UIsActive returns the value of the "u_is_active" field in the mutation.
func (m *UsersMutation) UIsActive() (r bool, exists bool) {
	v := m.u_is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldUIsActive returns the old "u_is_active" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUIsActive: %w", err)
	}
	return oldValue.UIsActive, nil
}

// ResetUIsActive resets all changes to the "u_is_active" field.
func (m *UsersMutation) ResetUIsActive() {
	m.u_is_active = nil
}

// SetUCreatedAt sets the "u_created_at" field.
func (m *UsersMutation) SetUCreatedAt(t time.Time) {
	m.u_created_at = &t
}

// UCreatedAt returns the value of the "u_created_at" field in the mutation.
func (m *UsersMutation) UCreatedAt() (r time.Time, exists bool) {
	v := m.u_created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUCreatedAt returns the old "u_created_at" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUCreatedAt: %w", err)
	}
	return oldValue.UCreatedAt, nil
}

// ClearUCreatedAt clears the value of the "u_created_at" field.
func (m *UsersMutation) ClearUCreatedAt() {
	m.u_created_at = nil
	m.clearedFields[users.FieldUCreatedAt] = struct{}{}
}

// UCreatedAtCleared returns if the "u_created_at" field was cleared in this mutation.
func (m *UsersMutation) UCreatedAtCleared() bool {
	_, ok := m.clearedFields[users.FieldUCreatedAt]
	return ok
}

// ResetUCreatedAt resets all changes to the "u_created_at" field.
func (m *UsersMutation) ResetUCreatedAt() {
	m.u_created_at = nil
	delete(m.clearedFields, users.FieldUCreatedAt)
}

// SetUPasswordUpdatedAt sets the "u_password_updated_at" field.
func (m *UsersMutation) SetUPasswordUpdatedAt(t time.Time) {
	m.u_password_updated_at = &t
}

// UPasswordUpdatedAt returns the value of the "u_password_updated_at" field in the mutation.
func (m *UsersMutation) UPasswordUpdatedAt() (r time.Time, exists bool) {
	v := m.u_password_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUPasswordUpdatedAt returns the old "u_password_updated_at" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUPasswordUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUPasswordUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUPasswordUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUPasswordUpdatedAt: %w", err)
	}
	return oldValue.UPasswordUpdatedAt, nil
}

// ClearUPasswordUpdatedAt clears the value of the "u_password_updated_at" field.
func (m *UsersMutation) ClearUPasswordUpdatedAt() {
	m.u_password_updated_at = nil
	m.clearedFields[users.FieldUPasswordUpdatedAt] = struct{}{}
}

// UPasswordUpdatedAtCleared returns if the "u_password_updated_at" field was cleared in this mutation.
func (m *UsersMutation) UPasswordUpdatedAtCleared() bool {
	_, ok := m.clearedFields[users.FieldUPasswordUpdatedAt]
	return ok
}

// ResetUPasswordUpdatedAt resets all changes to the "u_password_updated_at" field.
func (m *UsersMutation) ResetUPasswordUpdatedAt() {
	m.u_password_updated_at = nil
	delete(m.clearedFields, users.FieldUPasswordUpdatedAt)
}

// SetUExpiredAt sets the "u_expired_at" field.
func (m *UsersMutation) SetUExpiredAt(t time.Time) {
	m.u_expired_at = &t
}

// UExpiredAt returns the value of the "u_expired_at" field in the mutation.
func (m *UsersMutation) UExpiredAt() (r time.Time, exists bool) {
	v := m.u_expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUExpiredAt returns the old "u_expired_at" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldUExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUExpiredAt: %w", err)
	}
	return oldValue.UExpiredAt, nil
}

// ClearUExpiredAt clears the value of the "u_expired_at" field.
func (m *UsersMutation) ClearUExpiredAt() {
	m.u_expired_at = nil
	m.clearedFields[users.FieldUExpiredAt] = struct{}{}
}

// UExpiredAtCleared returns if the "u_expired_at" field was cleared in this mutation.
func (m *UsersMutation) UExpiredAtCleared() bool {
	_, ok := m.clearedFields[users.FieldUExpiredAt]
	return ok
}

// ResetUExpiredAt resets all changes to the "u_expired_at" field.
func (m *UsersMutation) ResetUExpiredAt() {
	m.u_expired_at = nil
	delete(m.clearedFields, users.FieldUExpiredAt)
}

// SetInGroupID sets the "in_group" edge to the Groups entity by id.
func (m *UsersMutation) SetInGroupID(id int) {
	m.in_group = &id
}

// ClearInGroup clears the "in_group" edge to the Groups entity.
func (m *UsersMutation) ClearInGroup() {
	m.clearedin_group = true
}

// InGroupCleared reports if the "in_group" edge to the Groups entity was cleared.
func (m *UsersMutation) InGroupCleared() bool {
	return m.clearedin_group
}

// InGroupID returns the "in_group" edge ID in the mutation.
func (m *UsersMutation) InGroupID() (id int, exists bool) {
	if m.in_group != nil {
		return *m.in_group, true
	}
	return
}

// InGroupIDs returns the "in_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InGroupID instead. It exists only for internal usage by the builders.
func (m *UsersMutation) InGroupIDs() (ids []int) {
	if id := m.in_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInGroup resets all changes to the "in_group" edge.
func (m *UsersMutation) ResetInGroup() {
	m.in_group = nil
	m.clearedin_group = false
}

// Where appends a list predicates to the UsersMutation builder.
func (m *UsersMutation) Where(ps ...predicate.Users) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UsersMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Users).
func (m *UsersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsersMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.u_pid != nil {
		fields = append(fields, users.FieldUPid)
	}
	if m.u_orgid != nil {
		fields = append(fields, users.FieldUOrgid)
	}
	if m.u_first_name != nil {
		fields = append(fields, users.FieldUFirstName)
	}
	if m.u_last_name != nil {
		fields = append(fields, users.FieldULastName)
	}
	if m.u_is_active != nil {
		fields = append(fields, users.FieldUIsActive)
	}
	if m.u_created_at != nil {
		fields = append(fields, users.FieldUCreatedAt)
	}
	if m.u_password_updated_at != nil {
		fields = append(fields, users.FieldUPasswordUpdatedAt)
	}
	if m.u_expired_at != nil {
		fields = append(fields, users.FieldUExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case users.FieldUPid:
		return m.UPid()
	case users.FieldUOrgid:
		return m.UOrgid()
	case users.FieldUFirstName:
		return m.UFirstName()
	case users.FieldULastName:
		return m.ULastName()
	case users.FieldUIsActive:
		return m.UIsActive()
	case users.FieldUCreatedAt:
		return m.UCreatedAt()
	case users.FieldUPasswordUpdatedAt:
		return m.UPasswordUpdatedAt()
	case users.FieldUExpiredAt:
		return m.UExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case users.FieldUPid:
		return m.OldUPid(ctx)
	case users.FieldUOrgid:
		return m.OldUOrgid(ctx)
	case users.FieldUFirstName:
		return m.OldUFirstName(ctx)
	case users.FieldULastName:
		return m.OldULastName(ctx)
	case users.FieldUIsActive:
		return m.OldUIsActive(ctx)
	case users.FieldUCreatedAt:
		return m.OldUCreatedAt(ctx)
	case users.FieldUPasswordUpdatedAt:
		return m.OldUPasswordUpdatedAt(ctx)
	case users.FieldUExpiredAt:
		return m.OldUExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Users field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case users.FieldUPid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUPid(v)
		return nil
	case users.FieldUOrgid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUOrgid(v)
		return nil
	case users.FieldUFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUFirstName(v)
		return nil
	case users.FieldULastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetULastName(v)
		return nil
	case users.FieldUIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUIsActive(v)
		return nil
	case users.FieldUCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUCreatedAt(v)
		return nil
	case users.FieldUPasswordUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUPasswordUpdatedAt(v)
		return nil
	case users.FieldUExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsersMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsersMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Users numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(users.FieldUCreatedAt) {
		fields = append(fields, users.FieldUCreatedAt)
	}
	if m.FieldCleared(users.FieldUPasswordUpdatedAt) {
		fields = append(fields, users.FieldUPasswordUpdatedAt)
	}
	if m.FieldCleared(users.FieldUExpiredAt) {
		fields = append(fields, users.FieldUExpiredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsersMutation) ClearField(name string) error {
	switch name {
	case users.FieldUCreatedAt:
		m.ClearUCreatedAt()
		return nil
	case users.FieldUPasswordUpdatedAt:
		m.ClearUPasswordUpdatedAt()
		return nil
	case users.FieldUExpiredAt:
		m.ClearUExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Users nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsersMutation) ResetField(name string) error {
	switch name {
	case users.FieldUPid:
		m.ResetUPid()
		return nil
	case users.FieldUOrgid:
		m.ResetUOrgid()
		return nil
	case users.FieldUFirstName:
		m.ResetUFirstName()
		return nil
	case users.FieldULastName:
		m.ResetULastName()
		return nil
	case users.FieldUIsActive:
		m.ResetUIsActive()
		return nil
	case users.FieldUCreatedAt:
		m.ResetUCreatedAt()
		return nil
	case users.FieldUPasswordUpdatedAt:
		m.ResetUPasswordUpdatedAt()
		return nil
	case users.FieldUExpiredAt:
		m.ResetUExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsersMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.in_group != nil {
		edges = append(edges, users.EdgeInGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case users.EdgeInGroup:
		if id := m.in_group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsersMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedin_group {
		edges = append(edges, users.EdgeInGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsersMutation) EdgeCleared(name string) bool {
	switch name {
	case users.EdgeInGroup:
		return m.clearedin_group
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsersMutation) ClearEdge(name string) error {
	switch name {
	case users.EdgeInGroup:
		m.ClearInGroup()
		return nil
	}
	return fmt.Errorf("unknown Users unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsersMutation) ResetEdge(name string) error {
	switch name {
	case users.EdgeInGroup:
		m.ResetInGroup()
		return nil
	}
	return fmt.Errorf("unknown Users edge %s", name)
}
